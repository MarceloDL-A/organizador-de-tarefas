[
    {
        "title": "a",
        "is_done": true,
        "date_created": "2024-05-09 16:30:18",
        "date_modified": "2024-05-09 16:30:33",
        "subtasks": [
            {
                "title": "s",
                "is_done": false,
                "date_created": "2024-05-09 16:30:30",
                "date_modified": "2024-05-09 16:30:36",
                "subtasks": [],
                "notes": ""
            }
        ],
        "notes": ""
    },
    {
        "title": "f",
        "is_done": false,
        "date_created": "2024-05-09 16:30:49",
        "date_modified": "2024-05-09 16:31:46",
        "subtasks": [],
        "notes": "Para implementar a funcionalidade desejada, vou garantir que as tarefas sejam movidas corretamente entre as abas \"Em Aberto\" e \"Conclu\u00eddas\". \n\n### C\u00f3digo Atualizado\n\n**Arquivo `app.py`**\n\n```python\n# ui/app.py\n\nimport tkinter as tk\nfrom tkinter import ttk, messagebox\nfrom ttkthemes import ThemedTk\nfrom models.task import Task\nfrom utils.logger import log_history\nfrom ui.task_list import TaskList\nimport json\nimport os\n\n\nclass TaskOrganizerApp(ThemedTk):\n    def __init__(self, base_dir):\n        super().__init__(theme=\"breeze\")\n        self.title(\"Task Organizer\")\n        self.state(\"zoomed\")  # Abrir em modo maximizado\n        self.configure(bg=\"#f4f4f4\")\n\n        # Diret\u00f3rio base e arquivos de persist\u00eancia\n        self.base_dir = base_dir\n        self.task_file = os.path.join(self.base_dir, \"tasks.json\")\n        self.history_file = os.path.join(self.base_dir, \"task_history.txt\")\n        self.tasks = []\n\n        # Carregar tarefas do arquivo\n        self.load_tasks()\n\n        # Notebook para as abas de \"Em Aberto\" e \"Conclu\u00eddas\"\n        self.notebook = ttk.Notebook(self)\n        self.notebook.pack(fill=tk.BOTH, expand=True)\n\n        # Criar as abas\n        self.frame_open_tasks = ttk.Frame(self.notebook, padding=\"10 10 10 10\")\n        self.frame_completed_tasks = ttk.Frame(self.notebook, padding=\"10 10 10 10\")\n\n        self.notebook.add(self.frame_open_tasks, text=\"Em Aberto\")\n        self.notebook.add(self.frame_completed_tasks, text=\"Conclu\u00eddas\")\n\n        # Gerenciar a lista de tarefas\n        self.task_list_open = TaskList(self.frame_open_tasks, self.tasks, self.history_file, self.save_tasks, completed=False, update_callback=self.update_task_lists)\n        self.task_list_completed = TaskList(self.frame_completed_tasks, self.tasks, self.history_file, self.save_tasks, completed=True, update_callback=self.update_task_lists)\n\n        # Interface de entrada para novas tarefas\n        task_entry_frame = ttk.Frame(self)\n        task_entry_frame.pack(pady=10)\n\n        ttk.Label(task_entry_frame, text=\"Task Title:\", font=(\"Helvetica\", 12)).pack(side=tk.LEFT, padx=(0, 10))\n        self.task_entry = ttk.Entry(task_entry_frame, width=50)\n        self.task_entry.pack(side=tk.LEFT)\n\n        self.add_task_button = ttk.Button(self, text=\"Add Task\", command=self.add_task)\n        self.add_task_button.pack(pady=5)\n\n        self.update_task_lists()\n\n    def add_task(self):\n        task_title = self.task_entry.get()\n        if not task_title:\n            messagebox.showwarning(\"Input Error\", \"Please enter a task title.\")\n            return\n        task = Task(task_title)\n        self.tasks.append(task)\n        self.task_entry.delete(0, tk.END)\n        self.update_task_lists()\n        self.save_tasks()\n        log_history(self.history_file, f\"Task created: {task_title}\")\n\n    def update_task_lists(self):\n        self.task_list_open.update_task_list()\n        self.task_list_completed.update_task_list()\n\n    def save_tasks(self):\n        try:\n            with open(self.task_file, \"w\") as file:\n                json.dump([task.to_dict() for task in self.tasks], file, indent=4)\n        except Exception as e:\n            log_history(self.history_file, f\"Error saving tasks: {e}\")\n            messagebox.showerror(\"Error\", f\"Failed to save tasks: {e}\")\n\n    def load_tasks(self):\n        print(f\"Loading tasks from: {self.task_file}\")\n        try:\n            if os.path.exists(self.task_file):\n                with open(self.task_file, \"r\") as file:\n                    tasks_data = json.load(file)\n                    self.tasks = [Task.from_dict(task_data) for task_data in tasks_data]\n            else:\n                self.tasks = []\n                self.save_tasks()\n        except json.JSONDecodeError as e:\n            messagebox.showerror(\"Error\", \"Failed to load tasks: The task file is corrupted or empty.\")\n            log_history(self.history_file, f\"Error loading tasks: {e}\")\n            self.tasks = []\n        except Exception as e:\n            messagebox.showerror(\"Error\", f\"Failed to load tasks: {e}\")\n            log_history(self.history_file, f\"Error loading tasks: {e}\")\n            self.tasks = []\n\ndef main():\n    app = TaskOrganizerApp(base_dir=os.path.dirname(__file__))\n    app.mainloop()\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\n**Arquivo `task_list.py`**\n\n```python\n# ui/task_list.py\n\nimport tkinter as tk\nfrom tkinter import ttk, simpledialog\nfrom models.task import Task\nfrom ui.notes import NotesEditor\nfrom utils.tooltip import Tooltip\nfrom utils.logger import log_history\n\n\nclass TaskList:\n    def __init__(self, parent, tasks, history_file, save_tasks_callback, completed=False, update_callback=None):\n        self.parent = parent\n        self.tasks = tasks\n        self.history_file = history_file\n        self.save_tasks = save_tasks_callback\n        self.completed = completed\n        self.update_callback = update_callback\n\n        # Frame que cont\u00e9m todas as tarefas\n        self.task_frame = ttk.Frame(self.parent, padding=\"10 10 10 10\")\n        self.task_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)\n\n        self.update_task_list()\n\n    def update_task_list(self):\n        for widget in self.task_frame.winfo_children():\n            widget.destroy()\n\n        for task in self.tasks:\n            if self._should_display_task(task):\n                self._create_task_frame(self.task_frame, task)\n\n    def _should_display_task(self, task):\n        if self.completed:\n            return task.is_done and self._are_all_subtasks_done(task)\n        return not task.is_done or not self._are_all_subtasks_done(task)\n\n    def _are_all_subtasks_done(self, task):\n        return all(self._are_all_subtasks_done(subtask) for subtask in task.subtasks) if task.subtasks else task.is_done\n\n    def _create_task_frame(self, parent_frame, task, indent=0):\n        task_frame = ttk.Frame(parent_frame, relief=tk.RAISED, borderwidth=1)\n        task_frame.pack(fill=tk.X, padx=(indent, 5), pady=5)\n\n        task_checkbox_var = tk.BooleanVar(value=task.is_done)\n        task_checkbox = ttk.Checkbutton(\n            task_frame,\n            text=f\"{task.title}\",\n            variable=task_checkbox_var,\n            command=lambda t=task: self.toggle_task(t)\n        )\n        task_checkbox.pack(side=tk.LEFT, padx=10)\n\n        add_subtask_button = ttk.Button(\n            task_frame,\n            text=\"Add Subtask\",\n            command=lambda t=task: self.add_subtask(t)\n        )\n        add_subtask_button.pack(side=tk.RIGHT, padx=5, pady=5)\n\n        notes_button = ttk.Button(\n            task_frame,\n            text=\"Notes\",\n            command=lambda t=task: NotesEditor(self.parent, t, self.save_tasks, self.history_file)\n        )\n        notes_button.pack(side=tk.RIGHT, padx=5, pady=5)\n\n        delete_task_button = ttk.Button(\n            task_frame,\n            text=\"Delete\",\n            command=lambda t=task: self.delete_task(t)\n        )\n        delete_task_button.pack(side=tk.RIGHT, padx=5, pady=5)\n\n        Tooltip.bind(task_checkbox, f\"Created: {task.date_created}\\nModified: {task.date_modified}\")\n\n        if task.subtasks:\n            completed_subtasks = sum(1 for subtask in task.subtasks if subtask.is_done)\n            progress = int((completed_subtasks / len(task.subtasks)) * 100)\n            progress_bar = ttk.Progressbar(task_frame, length=100, value=progress)\n            progress_bar.pack(side=tk.RIGHT, padx=10)\n\n            for subtask in task.subtasks:\n                self._create_task_frame(parent_frame, subtask, indent + 20)\n\n    def toggle_task(self, task):\n        task.is_done = not task.is_done\n        task.update_date_modified()\n        self.save_tasks()\n        log_history(self.history_file, f\"Task {'completed' if task.is_done else 'reopened'}: {task.title}\")\n\n        if self.update_callback:\n            self.update_callback()\n\n    def add_subtask(self, parent_task):\n        subtask_title = simpledialog.askstring(\"New Subtask\", \"Enter subtask title:\")\n        if not subtask_title:\n            return\n        subtask = Task(subtask_title)\n        parent_task.subtasks.append(subtask)\n        parent_task.update_date_modified()\n        self.save_tasks()\n        log_history(self.history_file, f\"Subtask added to {parent_task.title}: {subtask_title}\")\n\n        if self.update_callback:\n            self.update_callback()\n\n    def delete_task(self, task, parent_task=None):\n        if parent_task:\n            parent_task.subtasks.remove(task)\n            parent_task.update_date_modified()\n            log_history(self.history_file, f\"Subtask deleted from {parent_task.title}: {task.title}\")\n        else:\n            self.tasks.remove(task)\n            log_history(self.history_file, f\"Task deleted: {task.title}\")\n\n        self.save_tasks()\n\n        if self.update_callback:\n            self.update_callback()\n```\n\n### Gera\u00e7\u00e3o do Execut\u00e1vel\n\n**Comando PyInstaller**:\n\n```bash\npyinstaller --noconfirm TaskOrganizer.spec\n```\n\n**Arquivo `.spec`**\n\n```python\n# TaskOrganizer.spec\n\n# -*- mode: python -*-\n\nblock_cipher = None\n\nfrom PyInstaller.utils.hooks import collect_submodules\n\n# Coleta todos os subm\u00f3dulos\nmodels_submodules = collect_submodules\n\n('models')\nui_submodules = collect_submodules('ui')\nutils_submodules = collect_submodules('utils')\n\na = Analysis(\n    ['main.py'],\n    pathex=['.'],\n    binaries=[],\n    datas=[\n        ('models/*.py', 'models'),\n        ('ui/*.py', 'ui'),\n        ('utils/*.py', 'utils'),\n        ('tasks.json', '.'),\n        ('task_history.txt', '.'),\n    ],\n    hiddenimports=[\n        'ttkthemes',\n        'mistletoe',\n        *models_submodules,\n        *ui_submodules,\n        *utils_submodules\n    ],\n    hookspath=[],\n    runtime_hooks=[],\n    excludes=[],\n    win_no_prefer_redirects=False,\n    win_private_assemblies=False,\n    cipher=block_cipher,\n    noarchive=False,\n)\n\npyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)\n\nexe = EXE(\n    pyz,\n    a.scripts,\n    [],\n    exclude_binaries=True,\n    name='TaskOrganizer',\n    debug=False,\n    bootloader_ignore_signals=False,\n    strip=False,\n    upx=True,\n    console=False,\n    icon=None\n)\n\ncoll = COLLECT(\n    exe,\n    a.binaries,\n    a.zipfiles,\n    a.datas,\n    strip=False,\n    upx=True,\n    upx_exclude=[],\n    name='TaskOrganizer'\n)\n```\n\n### Estrutura do Projeto\n\n```plaintext\nOrganizador de Tarefas/\n\u251c\u2500\u2500 build/\n\u2502   \u2514\u2500\u2500 TaskOrganizer/\n\u251c\u2500\u2500 dist/\n\u2502   \u2514\u2500\u2500 TaskOrganizer/\n\u251c\u2500\u2500 models/\n\u2502   \u2514\u2500\u2500 task.py\n\u251c\u2500\u2500 ui/\n\u2502   \u251c\u2500\u2500 app.py\n\u2502   \u251c\u2500\u2500 notes.py\n\u2502   \u2514\u2500\u2500 task_list.py\n\u251c\u2500\u2500 utils/\n\u2502   \u251c\u2500\u2500 logger.py\n\u2502   \u2514\u2500\u2500 tooltip.py\n\u251c\u2500\u2500 main.py\n\u251c\u2500\u2500 TaskOrganizer.spec\n\u251c\u2500\u2500 tasks.json\n\u2514\u2500\u2500 task_history.txt\n```\n\n**Arquivo `main.py`**\n\n```python\n# main.py\n\nfrom ui.app import TaskOrganizerApp\n\ndef main():\n    app = TaskOrganizerApp(base_dir='.')\n    app.mainloop()\n\nif __name__ == \"__main__\":\n    main()\n```\n\n**Arquivo `models/task.py`**\n\n```python\n# models/task.py\n\nfrom datetime import datetime\n\nclass Task:\n    def __init__(self, title, is_done=False, date_created=None, date_modified=None, subtasks=None, notes=\"\"):\n        self.title = title\n        self.is_done = is_done\n        self.date_created = date_created if date_created else datetime.now().strftime('%Y-%m-%d %H:%M:%S')\n        self.date_modified = date_modified if date_modified else self.date_created\n        self.subtasks = subtasks if subtasks else []\n        self.notes = notes\n\n    def to_dict(self):\n        return {\n            \"title\": self.title,\n            \"is_done\": self.is_done,\n            \"date_created\": self.date_created,\n            \"date_modified\": self.date_modified,\n            \"subtasks\": [subtask.to_dict() for subtask in self.subtasks],\n            \"notes\": self.notes\n        }\n\n    @staticmethod\n    def from_dict(data):\n        subtasks = [Task.from_dict(subtask_data) for subtask_data in data.get(\"subtasks\", [])]\n        return Task(\n            data[\"title\"],\n            data[\"is_done\"],\n            data[\"date_created\"],\n            data.get(\"date_modified\", data[\"date_created\"]),\n            subtasks,\n            data.get(\"notes\", \"\")\n        )\n\n    def update_date_modified(self):\n        self.date_modified = datetime.now().strftime('%Y-%m-%d %H:%M:%S')\n```\n\n### Observa\u00e7\u00f5es\n\n- As tarefas movem-se automaticamente entre as abas conforme solicitado.\n- Certifique-se de que os arquivos `tasks.json` e `task_history.txt` estejam presentes na estrutura do projeto."
    }
]